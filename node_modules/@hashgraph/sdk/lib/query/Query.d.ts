/**
 * Generate a payment transaction given, aka. `TransferTransaction`
 *
 * @param {TransactionId} paymentTransactionId
 * @param {AccountId} nodeId
 * @param {?ClientOperator} operator
 * @param {Hbar} paymentAmount
 * @returns {Promise<HashgraphProto.proto.ITransaction>}
 */
export function _makePaymentTransaction(paymentTransactionId: TransactionId, nodeId: AccountId, operator: ClientOperator | null, paymentAmount: Hbar): Promise<HashgraphProto.proto.ITransaction>;
/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../channel/MirrorChannel.js").default} MirrorChannel
 * @typedef {import("../PublicKey.js").default} PublicKey
 * @typedef {import("../client/Client.js").ClientOperator} ClientOperator
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../logger/Logger.js").default} Logger
 */
/**
 * This registry holds a bunch of callbacks for `fromProtobuf()` implementations
 * Since this is essentially aa cache, perhaps we should move this variable into the `Cache`
 * type for consistency?
 *
 * @type {Map<HashgraphProto.proto.Query["query"], (query: HashgraphProto.proto.IQuery) => Query<*>>}
 */
export const QUERY_REGISTRY: Map<"getByKey" | "getBySolidityID" | "contractCallLocal" | "contractGetInfo" | "contractGetBytecode" | "ContractGetRecords" | "cryptogetAccountBalance" | "cryptoGetAccountRecords" | "cryptoGetInfo" | "cryptoGetLiveHash" | "cryptoGetProxyStakers" | "fileGetContents" | "fileGetInfo" | "transactionGetReceipt" | "transactionGetRecord" | "transactionGetFastRecord" | "consensusGetTopicInfo" | "networkGetVersionInfo" | "tokenGetInfo" | "scheduleGetInfo" | "tokenGetAccountNftInfos" | "tokenGetNftInfo" | "tokenGetNftInfos" | "networkGetExecutionTime" | "accountDetails" | undefined, (query: HashgraphProto.proto.IQuery) => Query<any>>;
/**
 * Base class for all queries that can be submitted to Hedera.
 *
 * @abstract
 * @template OutputT
 * @augments {Executable<HashgraphProto.proto.IQuery, HashgraphProto.proto.IResponse, OutputT>}
 */
export default class Query<OutputT> extends Executable<HashgraphProto.proto.IQuery, HashgraphProto.proto.IResponse, OutputT> {
    /**
     * Deserialize a query from bytes. The bytes should be a `proto.Query`.
     *
     * @template T
     * @param {Uint8Array} bytes
     * @returns {Query<T>}
     */
    static fromBytes<T>(bytes: Uint8Array): Query<T>;
    constructor();
    /**
     * The payment transaction ID
     *
     * @type {?TransactionId}
     */
    _paymentTransactionId: TransactionId | null;
    /**
     * The payment transactions list where each index points to a different node
     *
     * @type {HashgraphProto.proto.ITransaction[]}
     */
    _paymentTransactions: HashgraphProto.proto.ITransaction[];
    /**
     * The amount being paid to the node for this query.
     * A user can set this field explicitly, or we'll query the value during execution.
     *
     * @type {?Hbar}
     */
    _queryPayment: Hbar | null;
    /**
     * The maximum query payment a user is willing to pay. Unlike `Transaction.maxTransactionFee`
     * this field only exists in the SDK; there is no protobuf field equivalent. If and when
     * we query the actual cost of the query and the cost is greater than the max query payment
     * we'll throw a `MaxQueryPaymentExceeded` error.
     *
     * @type {?Hbar}
     */
    _maxQueryPayment: Hbar | null;
    /**
     * This is strictly used for `_getLogId()` which requires a timestamp. The timestamp it typically
     * uses comes from the payment transaction ID, but that field is not set if this query is free.
     * For those occasions we use this timestamp field generated at query construction instead.
     *
     * @type {number}
     */
    _timestamp: number;
    /**
     * Set an explicit payment amount for this query.
     *
     * The client will submit exactly this amount for the payment of this query. Hedera
     * will not return any remainder.
     *
     * @param {Hbar} queryPayment
     * @returns {this}
     */
    setQueryPayment(queryPayment: Hbar): this;
    /**
     * Set the maximum payment allowable for this query.
     *
     * @param {Hbar} maxQueryPayment
     * @returns {this}
     */
    setMaxQueryPayment(maxQueryPayment: Hbar): this;
    /**
     * Fetch the cost of this query from a consensus node
     *
     * @param {import("../client/Client.js").default<Channel, *>} client
     * @returns {Promise<Hbar>}
     */
    getCost(client: import("../client/Client.js").default<Channel, any>): Promise<Hbar>;
    /**
     * Set he payment transaction explicitly
     *
     * @param {TransactionId} paymentTransactionId
     * @returns {this}
     */
    setPaymentTransactionId(paymentTransactionId: TransactionId): this;
    /**
     * Get the payment transaction ID
     *
     * @returns {?TransactionId}
     */
    get paymentTransactionId(): TransactionId | null;
    /**
     * Is payment required for this query. By default most queries require payment
     * so the default implementation returns true.
     *
     * @protected
     * @returns {boolean}
     */
    protected _isPaymentRequired(): boolean;
    /**
     * Validate checksums of the query.
     *
     * @param {Client} client
     */
    _validateChecksums(client: import("../client/Client.js").default<any, any>): void;
    /**
     * Before we proceed exeuction, we need to do a couple checks
     *
     * @template {MirrorChannel} MirrorChannelT
     * @param {import("../client/Client.js").default<Channel, MirrorChannelT>} client
     * @returns {Promise<void>}
     */
    _beforeExecute<MirrorChannelT extends import("../channel/MirrorChannel.js").default>(client: import("../client/Client.js").default<import("../channel/Channel.js").default, MirrorChannelT>): Promise<void>;
    /**
     * @abstract
     * @internal
     * @param {HashgraphProto.proto.IResponse} response
     * @returns {HashgraphProto.proto.IResponseHeader}
     */
    _mapResponseHeader(response: HashgraphProto.proto.IResponse): HashgraphProto.proto.IResponseHeader;
    /**
     * @protected
     * @returns {HashgraphProto.proto.IQueryHeader}
     */
    protected _makeRequestHeader(): HashgraphProto.proto.IQueryHeader;
    /**
     * @abstract
     * @internal
     * @param {HashgraphProto.proto.IQueryHeader} header
     * @returns {HashgraphProto.proto.IQuery}
     */
    _onMakeRequest(header: HashgraphProto.proto.IQueryHeader): HashgraphProto.proto.IQuery;
    /**
     * @internal
     * @returns {HashgraphProto.proto.IQuery}
     */
    _makeRequest(): HashgraphProto.proto.IQuery;
    /**
     * @param {HashgraphProto.proto.Query} request
     * @returns {Uint8Array}
     */
    _requestToBytes(request: HashgraphProto.proto.Query): Uint8Array;
    /**
     * @param {HashgraphProto.proto.Response} response
     * @returns {Uint8Array}
     */
    _responseToBytes(response: HashgraphProto.proto.Response): Uint8Array;
}
/**
 * Cache for the cost query constructor. This prevents cyclic dependencies.
 *
 * @type {((query: Query<*>) => import("./CostQuery.js").default<*>)[]}
 */
export const COST_QUERY: ((query: Query<any>) => import("./CostQuery.js").default<any>)[];
export type Channel = import("../channel/Channel.js").default;
export type MirrorChannel = import("../channel/MirrorChannel.js").default;
export type PublicKey = import("../PublicKey.js").default;
export type ClientOperator = import("../client/Client.js").ClientOperator;
export type Client = import("../client/Client.js").default<any, any>;
export type Logger = import("../logger/Logger.js").default;
import TransactionId from "../transaction/TransactionId.js";
import AccountId from "../account/AccountId.js";
import Hbar from "../Hbar.js";
import * as HashgraphProto from "@hashgraph/proto";
import Executable from "../Executable.js";
