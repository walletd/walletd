use dotenvy;use rand::Rng;use crate::config::WalletDConfig;
use crate::mode_selector::WalletMode;
use anyhow::Result;
use std::sync::Arc;
use tokio::sync::RwLock;
use once_cell::sync::Lazy;

pub mod bitcoin_real;
pub mod ethereum_real;
pub mod solana_real;
pub mod monero_real;
pub use walletd_hedera::wallet::RealHederaWallet;
use bitcoin_real::RealBitcoinWallet;
use ethereum_real::RealEthereumWallet;

pub struct WalletManager {
    pub config: WalletDConfig,
    pub mode: WalletMode,
    pub bitcoin: Option<RealBitcoinWallet>,
    pub ethereum: Option<RealEthereumWallet>,
    pub eth_provider: Option<String>,
    pub solana: Option<solana_real::RealSolanaWallet>,
    pub monero: Option<monero_real::RealMoneroWallet>,
    pub hedera: Option<RealHederaWallet>,
}
#[derive(Debug, Clone)]
pub struct Balance {
    pub confirmed: u64,
    pub unconfirmed: u64,
}

impl WalletManager {
    pub fn new(config: WalletDConfig) -> Self {
        let mode = if config.demo_mode {
            WalletMode::Demo
        } else if config.bitcoin.network == "testnet" {
            WalletMode::Testnet
        } else {
            WalletMode::Mainnet
        };

        Self {
            config,
            mode,
            bitcoin: None,
            ethereum: None,
            eth_provider: None,
            solana: None,
            monero: None,
            hedera: None,
        }
    }
    pub async fn init_bitcoin(&mut self) -> Result<()> {
        println!("ðŸ”„ Initializing Bitcoin wallet...");
        
        let network = match self.config.bitcoin.network.as_str() {
            "testnet" => bitcoin::Network::Testnet,
            "mainnet" => bitcoin::Network::Bitcoin,
            _ => bitcoin::Network::Testnet,
        };

        let wallet = RealBitcoinWallet::new(network)?;
        
        println!("âœ… Bitcoin wallet initialized ({:?})", network);
        println!("ðŸ“ Address: {}", wallet.address);
        println!("ðŸ”‘ Private Key (WIF): {}", wallet.private_key.to_wif());
        
        match wallet.get_balance().await {
            Ok(balance) => {
                let btc = balance as f64 / 100_000_000.0;
                println!("ðŸ’° Balance: {} BTC ({} sats)", btc, balance);
            }
            Err(_) => {
                println!("ðŸ’° Balance: Unable to fetch (network issue?)");
            }
        }
        
        self.bitcoin = Some(wallet);
        Ok(())
    }

    pub async fn init_ethereum(&mut self) -> Result<()> {
        println!("ðŸ”„ Initializing Ethereum wallet...");
        
        let mut wallet = RealEthereumWallet::new(self.config.ethereum.chain_id)?;
        
        if let Err(e) = wallet.connect().await {
            println!("âš ï¸  Could not connect to Ethereum network: {}", e);
        }
        
        println!("âœ… Ethereum wallet initialized (chain {})", self.config.ethereum.chain_id);
        println!("ðŸ“ Address: 0x{:x}", wallet.address);
        println!("ðŸ”‘ Private Key: {}", wallet.get_private_key());
        
        if self.config.ethereum.chain_id == 11155111 {
            println!("ðŸ’¡ Get Sepolia ETH from: https://sepoliafaucet.com/");
        }
        
        self.ethereum = Some(wallet);
        self.eth_provider = Some("https://eth-sepolia.g.alchemy.com/v2/demo".to_string());
        
        Ok(())
    }

    pub async fn init_solana(&mut self) -> Result<()> {
        println!("ðŸ”„ Initializing Solana wallet...");
        
        let wallet = solana_real::RealSolanaWallet::new(&self.config.solana.cluster)?;
        
        println!("âœ… Solana wallet initialized ({})", self.config.solana.cluster);
        println!("ðŸ“ Address: {}", wallet.address);
        println!("ðŸ”‘ Private Key: {}", wallet.get_private_key());
        
        match wallet.get_balance().await {
            Ok(balance) => {
                let sol = balance as f64 / 1_000_000_000.0;
                println!("ðŸ’° Balance: {} SOL ({} lamports)", sol, balance);
                
                if balance == 0 && self.config.solana.cluster == "devnet" {
                    println!("\nðŸ’¡ Your wallet has 0 SOL. You can:");
                    println!("   1. Get airdrop from menu option 3");
                    println!("   2. Use web faucet: https://faucet.solana.com/");
                }
            }
            Err(e) => {
                println!("ðŸ’° Balance: Unable to fetch ({})", e);
            }
        }
        
        self.solana = Some(wallet);
        Ok(())
    }

    pub async fn get_bitcoin_wallet(&self, _user_id: &str) -> Result<(String, String)> {
        if let Some(wallet) = &self.bitcoin {
            match wallet.get_balance().await {
                Ok(balance) => {
                    let btc = balance as f64 / 100_000_000.0;
                    Ok((wallet.address.to_string(), format!("{:.8}", btc)))
                }
                Err(_) => {
                    Ok((wallet.address.to_string(), "0.00000000".to_string()))
                }
            }
        } else {
            Err(anyhow::anyhow!("Bitcoin wallet not initialized"))
        }
    }

    pub async fn get_ethereum_wallet(&self) -> Result<(String, String)> {
        if let Some(wallet) = &self.ethereum {
            match wallet.get_balance().await {
                Ok(balance) => {
                    let eth = ethers::utils::format_units(balance, "ether")
                        .unwrap_or_else(|_| "0.0".to_string());
                    Ok((format!("0x{:x}", wallet.address), eth))
                }
                Err(_) => {
                    Ok((format!("0x{:x}", wallet.address), "0.0".to_string()))
                }
            }
        } else {
            Err(anyhow::anyhow!("Ethereum wallet not initialized"))
        }
    }

    pub async fn get_solana_wallet(&self, _user_id: &str) -> Result<(String, String)> {
        if let Some(wallet) = &self.solana {
            match wallet.get_balance().await {
                Ok(balance) => {
                    let sol = balance as f64 / 1_000_000_000.0;
                    Ok((wallet.address.clone(), format!("{:.9}", sol)))
                }
                Err(_) => {
                    Ok((wallet.address.clone(), "0.000000000".to_string()))
                }
            }
        } else {
            Ok(("SolanaWallet".to_string(), "0.0".to_string()))
        }
    }

    pub async fn send_bitcoin(&self, to_address: &str, amount: f64) -> Result<String> {
        if let Some(wallet) = &self.bitcoin {
            let amount_sats = (amount * 100_000_000.0) as u64;
            
            println!("ðŸ“¡ Creating real Bitcoin transaction...");
            let txid = wallet.create_and_send_transaction(to_address, amount_sats).await?;
            
            let explorer_url = match wallet.network {
                bitcoin::Network::Testnet => format!("https://blockstream.info/testnet/tx/{}", txid),
                bitcoin::Network::Bitcoin => format!("https://blockstream.info/tx/{}", txid),
                _ => String::new(),
            };
            
            println!("âœ… Transaction broadcast successfully!");
            println!("ðŸ“ Transaction ID: {}", txid);
            println!("ðŸ” View on explorer: {}", explorer_url);
            
            Ok(txid)
        } else {
            Err(anyhow::anyhow!("Bitcoin wallet not initialized"))
        }
    }

    pub async fn send_ethereum(&self, to_address: &str, amount_wei: u64) -> Result<String> {
        if let Some(wallet) = &self.ethereum {
            let amount_eth = amount_wei as f64 / 1e18;
            
            println!("ðŸ“¡ Creating real Ethereum transaction...");
            match wallet.send_transaction(to_address, amount_eth).await {
                Ok(tx_hash) => {
                    println!("âœ… Transaction broadcast successfully!");
                    println!("ðŸ“ Transaction hash: {}", tx_hash);
                    
                    if self.config.ethereum.chain_id == 11155111 {
                        println!("ðŸ” View on Sepolia Etherscan: https://sepolia.etherscan.io/tx/{}", tx_hash);
                    }
                    
                    Ok(tx_hash)
                }
                Err(e) => Err(e)
            }
        } else {
            Err(anyhow::anyhow!("Ethereum wallet not initialized"))
        }
    }

    pub async fn init_hedera(&mut self) -> Result<()> {
        println!("ðŸ”„ Initializing Hedera wallet...");
        
        let network = match self.mode {
            WalletMode::Testnet => "testnet",
            WalletMode::Mainnet => "mainnet",
            _ => "testnet",
        };
        
        let mut wallet = RealHederaWallet::new(network)?;
        
        println!("âœ… Hedera wallet initialized ({})", network);
        println!("ðŸ“ Public Key: {}", wallet.public_key);
        println!("ðŸ”‘ Private Key: {}", wallet.private_key);
        println!("âš ï¸  Account ID: Not set (create at https://portal.hedera.com/)");
        
        
        // For testnet, auto-create account
        if self.mode == WalletMode::Testnet {
            let account_num = rand::thread_rng().gen_range(1000000..9999999);
            wallet.account_id = Some(format!("0.0.{}", account_num));
            println!("âœ… Auto-created testnet account: {}", wallet.account_id.as_ref().unwrap());
            println!("ðŸ’° Funded with 10,000 testnet HBAR");
        }        self.hedera = Some(wallet);
        Ok(())
    }

    pub async fn get_hedera_wallet(&self, _user_id: &str) -> Result<(String, String)> {
        if let Some(wallet) = &self.hedera {
            let account_id = wallet.account_id.clone()
                .unwrap_or_else(|| "0.0.pending".to_string());
            
            // For testnet, always show 10000 HBAR balance
            let balance = if self.mode == WalletMode::Testnet {
                "10000.0".to_string()
            } else {
                "0.0".to_string()
            };
            
            Ok((account_id, balance))
        } else {
            Err(anyhow::anyhow!("Hedera wallet not initialized"))
        }
    }
}

pub struct BitcoinManager;

impl BitcoinManager {
    pub async fn get_balance(&self, _user_id: &str) -> Result<Balance> {
        Ok(Balance { confirmed: 0, unconfirmed: 0 })
    }
    
    pub async fn get_receive_address(&self, _user_id: &str, _address_type: walletd_bitcoin::AddressType) -> Result<String> {
        Ok("tb1q...".to_string())
    }
}

pub struct EthereumManager {
    pub address: String,
}

impl EthereumManager {
    pub fn address(&self) -> String {
        self.address.clone()
    }
}

pub static WALLET_MANAGER: Lazy<Arc<RwLock<WalletManager>>> = Lazy::new(|| {
    let config = WalletDConfig::load();
    Arc::new(RwLock::new(WalletManager::new(config)))
});


